{"ts":1375633962865,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function Player(){\n    \n    this.pos = {x:16*6, y:16*6};\n    this.spawningPos = {x:16*6, y:16*6};\n    this.posPrevious = {x:0,y:0};\n    this.lives = 1;\n    this.maxLives = 1; // when lives pass the max lives the tank die (done this way to use the value lives in the animation)\n    this.speed = 2;\n    this.bulletSpeed = 7;\n    this.type = \"player\";\n    this.subtype = 1;\n    this.subsubtype = \"\"; // this tank carries an item\n    this.currentSpeed = {x:0,y:0};\n    this.input = {};\n    this.spriteSheet = null;\n    this.bulletSpriteSheet = null;\n    this.explosionSpritesheet = null; //eitcha lele\n    this.bigExplosionSpritesheet = null;  \n    this.spawnSpriteSheet = null;\n    this.currentSprite = null;\n    this.shieldSprite = null;\n    this.direction = {Up:\"Up\",Right:\"Right\",Down:\"Down\",Left:\"Left\"};//fazendo dessa forma pq com o enum n tem garantia q vai ser string, e o nome dos sprites pode mudar no futuro\n    this.animationContext = null;\n    //this.shieldAnimContext = null;\n    this.currentDirection = this.direction.Up;\n    this.currentCollisionFunc = this.defaultCollision;\n    this.fireCooldownTime = 0.5*1000; //in miliseconds\n    this.spawnTime = 1.5*1000; // in ms\n    this.spawning = false;\n    this.isShielded = false;\n    this.ignore = [];\n    this.isDead = false;\n    this.spawnerInstance = null;\n    this.itemSpanwerInstance = null;\n    //this.bornTogether = false;\n    //this.shieldTime = 1*1000; // in ms\n    \n    this.firstUpdate = true;\n    this.maxBullets = 1;\n    this.canFire = true;\n    this.bullets = [];\n    \n    this.collisionInstance = null;\n    \n    this.setItemSpawner = function(is){\n        this.itemSpanwerInstance = is;\n    }\n    \n    this.setInput = function(input){\n        this.input = input;\n    };\n    \n    this.spawnPlayer = function(){\n        this.pos = {x: this.spawningPos.x, y: this.spawningPos.y};\n        this.posPrevious = {x: this.spawningPos.x, y:this.spawningPos.y};\n        this.currentSpeed = {x:0,y:0};\n        \n        this.spawning = true;\n        setTimeout((function(self) {            //Self-executing func which takes 'this' as self\n                         return function() {    //Return a function in the context of 'self'\n                             self.spawning = false;\n                             if (self.type === \"player\") self.setShieldOn(1*3000);\n                             if (self.subsubtype === \"special\") self.itemSpanwerInstance.clearItems();\n                         };\n                     })(this),\n                     this.spawnTime );\n    }\n    \n    this.setShieldOn = function(time){\n        this.isShielded = true;\n        setTimeout((function(self) {         //Self-executing func which takes 'this' as self\n                         return function() {   //Return a function in the context of 'self'\n                             self.isShielded = false;\n                         };\n                     })(this),\n                     time );\n        \n    }\n    \n    //called each draw frame\n    this.update = function(){\n        \n        if (this.firstUpdate){\n            this.spawnPlayer();\n            this.firstUpdate = false;\n            //return false;\n        }\n        \n        if (this.spawning) {\n            this.currentSprite = this.spawnSpriteSheet.getSprite(\"spawn\");            \n        } else if (this.isDead){\n            \n        } else {     \n            if (this.isShielded){\n                this.shieldSprite = this.spriteSheet.getSprite(\"shield\");\n            } else {\n                this.shieldSprite = null;\n            }\n\n            for (var i=this.ignore.length-1; i>=0; i--){\n                var p = this.ignore[i];        \n                var pos = {x:(this.pos.x+16), y:(this.pos.y+16)}; // get the center pos\n                var pos2 = {x:(p.pos.x+16), y:(p.pos.y+16)};\n                if (Math.pow(pos.x-pos2.x,2) + Math.pow(pos.y-pos2.y,2) > 35*35){ //for not using sqrt\n                    this.ignore.splice(i,1);\n                }\n            }\n        \n            var gridSize =16;\n            this.currentSpeed.x = 0;\n            this.currentSpeed.y = 0;\n            \n            this.posPrevious.x = this.pos.x;\n            this.posPrevious.y = this.pos.y;\n                \n            //eu nao consegui gravar porque isso aqui funcionou:\n            if (this.input.value.x !== 0 ){\n                //this.pos.x += this.input.value.x*this.speed; \n                this.currentSpeed.x = this.input.value.x*this.speed;\n                this.pos.x +=  this.currentSpeed.x;\n                if (this.input.value.x > 0) this.currentDirection = this.direction.Right; else this.currentDirection = this.direction.Left;\n                 //put him back on the grid:\n                this.pos.y = Math.round((this.pos.y )/gridSize)*gridSize;\n            }else if (this.input.value.y !== 0){\n                //this.pos.y += this.input.value.y*this.speed;\n                this.currentSpeed.y = this.input.value.y*this.speed;\n                this.pos.y +=  this.currentSpeed.y;\n                if (this.input.value.y > 0) this.currentDirection = this.direction.Down; else this.currentDirection = this.direction.Up;\n                //put him back on the grid:\n                this.pos.x = Math.round((this.pos.x )/gridSize)*gridSize;\n            } \n            \n            // instantiate bullet\n            if (this.input.value.fire === true && this.bullets.length < this.maxBullets && this.canFire){\n                //console.log(\"Shooting\");\n                if (this.bulletSpriteSheet){\n                    this.canFire = false;\n                    var bulletSprite = this.bulletSpriteSheet.getSprite(\"bullet\"+this.currentDirection);\n                    var newbullet = new Bullet(this.pos.x +gridSize/2, this.pos.y +gridSize/2, bulletSprite);\n                   \n                    newbullet.currentDirection = this.currentDirection;\n                    newbullet.bulletSpeed = this.bulletSpeed;\n                    newbullet.calculateSpeed();\n                    newbullet.owner = this;\n                    this.bullets.push(newbullet);\n                    this.collisionInstance.createDynamicCollider({obj:newbullet, type:newbullet.type ,w:16,h:16}, newbullet.defaultCollision);\n                    //relaoding:\n                \n                    setTimeout((function(self) {         //Self-executing func which takes 'this' as self\n                                     return function() {   //Return a function in the context of 'self'\n                                         self.fireCoolDown(); //Thing you wanted to run as non-window 'this'\n                                     };\n                                 })(this),\n                                 this.fireCooldownTime );\n                    \n                }\n            }\n            \n            if (this.spriteSheet){ \n                if (this.animationContext === null){\n                    this.animationContext = this.spriteSheet.createContext(); \n                }\n                //console.log(this.spriteSheet.getSprite(\"player\"+this.currentDirection,this.animationContext));\n                this.currentSprite = this.spriteSheet.getSprite(this.subsubtype+ this.type+(this.subtype+(this.lives-1))+this.currentDirection,this.animationContext);\n            }\n            //console.log(this.type+this.subtype+this.currentDirection);\n            \n            //console.log(\"\"+this.type+this.subtype+this.currentDirection+this.lives);\n            if (this.input.value.x === 0 && this.input.value.y === 0 ){\n                this.spriteSheet.getAnimation(this.subsubtype+this.type+(this.subtype+(this.lives-1))+this.currentDirection,this.animationContext).stop();\n            } else {\n                this.spriteSheet.getAnimation(this.subsubtype+this.type+(this.subtype+(this.lives-1))+this.currentDirection,this.animationContext).continue();\n            }    \n        } \n        //if (this.isDead){\n        //    this.currentSprite = null;\n        //}\n        //remove bullets\n        this.removeBullets();\n        \n        //update bullets\n        for (var b in this.bullets)               \n            this.bullets[b].update();\n            \n        \n        if (this.isDead && this.bullets.length===0){\n            this.spawnerInstance.removeDeadEnemy(this);\n        }\n    };\n    \n    this.fireCoolDown=function(){\n        this.canFire = true;\n        \n    }\n    \n    this.die = function(){\n        //this.lives++;\n        if (this.subsubtype === \"special\"){\n            //spawn item\n            this.itemSpanwerInstance.spawnItem();\n            this.subsubtype = \"\";\n        }\n        \n        if (this.type===\"player\" || (++this.lives) > this.maxLives){\n            allExplosions.push(new Explosion(this.pos.x,this.pos.y,explosionSpriteSheet, \"Big\"));\n            this.shieldSprite = null;\n            //this.bullets = []; // erase all player bullets\n            if (this.type===\"player\"){\n                this.spawnPlayer();\n            } else {\n                this.isDead = true;\n                this.currentSprite = null;\n                this.collisionInstance.removeDynamicCollider(this);\n                //this.spawnerInstance.removeDeadEnemy(this);\n            }\n        }\n    }\n    \n    this.removeBullets = function(){\n        for (var i=this.bullets.length-1; i>=0; i--){\n            if (this.bullets[i].remove){\n                this.collisionInstance.removeDynamicCollider( this.bullets[i] );\n                //create new collider for explosion\n                var explinfo = this.bullets[i].createExplosionObject()\n                this.collisionInstance.createDynamicCollider(explinfo, this.bullets[i].deafultExplosionCollision, this.bullets[i].explosionRect.offx, this.bullets[i].explosionRect.offy);\n                setTimeout((function(self) { return function() { self.col.removeDynamicCollider(self.obj)};})({col:this.collisionInstance, obj:explinfo.obj}), 1000); // <--- bah, to muito louco, wololo\n                this.bullets.splice(i,1);              \n            }\n        }\n    }\n    \n    this.isThisBulletFromThisPlayer = function(bullet){\n        for (var i=this.bullets.length-1; i>=0; i--){\n            if (this.bullets[i] == bullet){\n                return true;\n            }\n        }\n        return false;\n    };\n    \n    \n    // create a dynamic collider for the player, and a callback function that will execute when this collider hits something\n    // the function has access to the object itself and the other object it collided.\n    this.defaultCollision = function(info, other){      // function that is called when this obj collides with something\n        var self = info.obj;\n        var gridSize = 16;\n        if (other.type===\"tile\"  || other.type===\"invisible\"){\n            info.obj.pos.y = Math.round((info.obj.pos.y )/gridSize)*gridSize;\n            info.obj.pos.x = Math.round((info.obj.pos.x )/gridSize)*gridSize;  \n        }\n        if (other.type===\"player\" || other.type===\"enemy\" ){\n            if (info.obj.input.value.x === 0 && info.obj.input.value.y===0) return; //boa\n\n            var tile = {x:0,y:0};\n            tile.x = Math.floor(other.obj.pos.x+gridSize) - Math.floor(info.obj.pos.x+gridSize);\n            tile.y = Math.floor(other.obj.pos.y+gridSize) - Math.floor(info.obj.pos.y+gridSize);\n            \n            // this dumb player walk inside the spawn of another player\n            if (self.spawning) {\n                if (!contains(self.ignore, other.obj)) self.ignore.push(other.obj);\n                if (!contains(other.obj.ignore, self)) other.obj.ignore.push(self);\n                return;\n            }\n            \n            if (contains(self.ignore, other.obj)) {\n                return;\n            }\n            \n            \n            // if any of this is true, the obj should not be blocked\n            if (tile.x <= -26 && (info.obj.currentSpeed.y !== 0 || info.obj.currentSpeed.x > 0)) return;\n            if (tile.x >=  26 && (info.obj.currentSpeed.y !== 0 || info.obj.currentSpeed.x < 0)) return;\n            if (tile.y <= -26 && (info.obj.currentSpeed.x !== 0 || info.obj.currentSpeed.y > 0)) return;\n            if (tile.y >=  26 && (info.obj.currentSpeed.x !== 0 || info.obj.currentSpeed.y < 0)) return;            \n            \n            info.obj.pos.x = info.obj.posPrevious.x;\n            info.obj.pos.y = info.obj.posPrevious.y;\n\n            // align tank on the grid\n            if (info.obj.currentSpeed.x !== 0)\n                info.obj.pos.y = Math.round((info.obj.pos.y )/gridSize)*gridSize;            \n            else if (info.obj.currentSpeed.y !== 0)\n                info.obj.pos.x = Math.round((info.obj.pos.x )/gridSize)*gridSize;\n        }\n        \n        \n        if (self.spawning === false && other.type === \"bullet\" && !other.obj.remove){\n            \n            if (other.obj.owner.type !== self.type){    // if they are of different class, they can kill each other (player hit enemy, or enemy hit player)\n                other.obj.remove = true;\n                self.die();\n            } else {\n      \n            }             \n        }\n                 \n    };\n\n    this.setCollisionInstance = function(col){\n        this.collisionInstance = col;\n        this.createCollider();\n    }\n    \n    this.createCollider = function(){  \n        this.collisionInstance.createDynamicCollider({obj:this, type:this.type ,w:32,h:32}, this.defaultCollision); \n    };\n\n            \n        \n    \n} "]],"start1":0,"start2":0,"length1":0,"length2":13407}]],"length":13407}
