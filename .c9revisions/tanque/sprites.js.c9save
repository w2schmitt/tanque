{"ts":1376415442680,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\nfunction SpriteSheet(img){\n    this.sprite_array = {};    \n    this.sheet = img;\n    this.initialized = false;\n    this.spriteNames = []; \n    this.spriteReferences = {}; \n    this.animations = {};\n    this.contextalizedAnimations = {};\n    \n    this.context = 0;\n    this.createContext = function(){\n        return this.context++;  \n    }\n    \n    this.createSprites = function ( resX, resY,  x, y,optionalOffsetX,optionalOffsetY){ \n        optionalOffsetX = optionalOffsetX | 0;\n        optionalOffsetY = optionalOffsetY | 0;\n        if (!this.loaded()) return false;        \n        var sprites_arr = this.getSpriteArray(resX,resY);\n        this.sheet.loadPixels();        // wut? --> tem que chamar isso pro get funfar... ahhhn\n        for (var i=0; i<x; i++){\n            var spriteLine = [];\n            for (var j=0; j<y; j++){                 \n                spriteLine.push( this.sheet.get(optionalOffsetX + i*resX, optionalOffsetY + j*resY, resX, resY));\n            }\n            sprites_arr.push(spriteLine);\n        }           \n        this.initialized = true;\n    };\n    \n    // get an array of sprites that has the specified resolution\n    this.getSpriteArray = function(resX, resY){\n        if (this.sprite_array.hasOwnProperty([resX,resY]))\n            return this.sprite_array[[resX,resY]];              \n        this.sprite_array[[resX,resY]] = [];\n        return this.sprite_array[[resX,resY]];\n    }\n\n    // rect -> [x,y,w,h]  -> Agora Ã© um rect de verdade   (w*h == names.length)\n    // names -> enum(\"none\", \"brick\", ...)\n    this.setRectSprites = function(rect,  resX, resY, names){  \n        var r = {x:rect[0], y:rect[1], w:rect[2], h:rect[3]};        \n        if (names.length != r.w*r.h) {\n            console.log(\"Name of sprites and Rect do not match\");\n            return false;        \n        }      \n        for (var i=r.x; i<(r.x+r.w); i++){\n            for (var j=r.y; j<(r.y+r.h); j++){\n                this.setSprite(i,j, names[(i-r.x) + (j-r.y)*r.w], resX, resY);\n            }\n        }\n    };\n    \n    this.loaded = function(){\n        return this.sheet.loaded;\n    };\n    \n    this.setAnimation = function(spriteNames,animationName,optionalFps,optionalRepeat){\n        if (optionalRepeat == null){optionalRepeat = true}\n        //optionalFps will never be used LOL\n        if (this.animations[animationName] != null) return false;\n        this.animations[animationName] = new Animation(optionalFps,optionalRepeat);\n        for (var spriteName in spriteNames ){\n            spriteName = spriteNames[spriteName];\n            this.animations[animationName].addFrame (this.spriteReferences[spriteName]);\n        }\n        \n    };\n    \n\n    this.setSprite = function(x,y,name, resX, resY){\n        var sprites_arr = this.getSpriteArray(resX,resY);\n        if (sprites_arr != null){\n            this.spriteNames.push(name);\n            this.spriteReferences[name] = sprites_arr[x][y]; \n        } else console.log(\"cannot found sprites with resolution: \",resX, resY);\n    };\n    \n    this.getSprite = function(name,optionalContext){\n        //var sprite =  this.spriteReferences[name];\n        //if (sprite != null ) return sprite;\n        return (this.spriteReferences[name] || this.getAnimation(name,optionalContext).getSprite());\n          \n    };\n    \n    \n    this.getAnimation = function(name,optionalContext){\n        \n        if (optionalContext) {\n            if (this.contextalizedAnimations[name] == null){\n                this.contextalizedAnimations[name] = {};\n            }\n            if (this.contextalizedAnimations[name][optionalContext] == null){ \n                //copy animation to the context:\n                this.contextalizedAnimations[name][optionalContext] = this.animations[name].clone();\n                \n            }\n            \n            return this.contextalizedAnimations[name][optionalContext] ;\n            \n        }else{\n             return this.animations[name];\n        }\n    };\n    \n    //nao precisa mais dessa funcao de update <--- magic\n    /*this.update = function(){\n        \n        for (var i in this.animations){\n            this.animations[i].update(); \n        }\n    };*/\n}\n\nfunction Animation(optionalFps,optionalRepeat){\n    \n    this.currentFrame = 0;\n    this.currentSprite = null;\n    this.frames = [];\n    this.animationInterval = null;\n    this.fps  = 30;\n    if (optionalFps){\n        this.fps = optionalFps;\n    }\n    this.repeat = true;\n    if (optionalRepeat != null){\n        this.repeat = optionalRepeat;\n    }\n    \n    this.sprites = [];\n    this.update = function(){ \n         this.currentSprite = this.frames[this.currentFrame];\n    };\n    \n    this.addFrame = function(frame){\n        this.frames.push(frame); \n        this.update();\n    };\n    \n    this.getSprite = function(){\n        return this.currentSprite;\n    };\n    \n    this.stop = function(){\n        if (this.animationInterval != null){\n            clearInterval(this.animationInterval);\n            this.animationInterval = null;\n        }\n    };\n    this.nextFrame = function(){\n        if (this.frames.length > 0){\n            this.currentFrame += 1;\n           \n            // mudei aqui\n            if (this.currentFrame == this.frames.length & !this.repeat){ \n                this.stop();\n                this.currentFrame = null;\n            } else {               \n                this.currentFrame %= this.frames.length;\n            }\n        }\n       this.update();\n        \n    };\n    this.isStopped = function(){\n        return (this.animationInterval == null);\n        \n    }\n    this.start = function(){\n        this.stop();\n        this.animationInterval = setInterval(\n                //loucura pra nao perder a referencia do this\n                (function(self) {         //Self-executing func which takes 'this' as self\n                     return function() {   //Return a function in the context of 'self'\n                         self.nextFrame(); //Thing you wanted to run as non-window 'this'\n                     }\n                 })(this),\n                 1000.0/this.fps \n            )\n        this.nextFrame();\n    };\n    this.continue = function(){\n        if (this.animationInterval == null){\n            this.start(); \n        } \n    }\n    this.clone = function(){\n        var newAnimation = new Animation(this.fps,this.repeat);\n        //copy all shit:\n        //newAnimation.currentFrame = this.currentFrame;\n        newAnimation.currentSprite = this.currentSprite;\n        //newAnimation.frames = this.frames ;\n        newAnimation.frames = [];\n        for (var i in this.frames){\n            newAnimation.frames.push(this.frames[i]);\n        }\n        //newAnimation.fps = this.fps;\n        //newAnimation.repeat =  this.repeat;\n        newAnimation.update();\n        return newAnimation;\n        \n    }\n    this.start();\n    \n}\n\n"]],"start1":0,"start2":0,"length1":0,"length2":6838}]],"length":6838}
